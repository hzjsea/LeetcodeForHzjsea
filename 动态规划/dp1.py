# 走楼梯

# 10个台阶 每次走1步 或者走2步 有多少种走法


# 下楼梯的走法
# 第一轮走1步 还剩 9个台阶
# 第一轮走2步 还剩 8个台阶

# 抛开之前的想法， 我们来看 9个台阶有几个走法 或者说8个台阶有几个走法
# 第一轮走1步 还剩 8个台阶
# 第一轮走2步 还剩 7个台阶

# 所以方案就出来了，我们下楼的每一步都跟走1步和走2步有关系

# 那么我们假设到第九个台阶是走f(9)个走法, 到第八个台阶是有f(8)个走法， 而他们最后一步的走法是固定的
# 所以 走到 10个台阶的走法一共有f(10) = [f(9) + f(8)]个走法

# 那么f(9) 该怎么得到 f(9) = f(8) + f(7)
# f(8） = f(6) + f(7)

# 所以可得
# f(10) = f(9) + f(8)  # 最优子结构
# f(9) = f(8) + f(7)
# f(8) = f(7) + f(6)
# f(7) = f(6) + f(5)
# f(6) = f(5) + f(4)
# f(5) = f(4) + f(3)
# f(4) = f(3) + f(2)
# f(3) = f(2) + f(1)
# f(2) = 2  # 两种走法
# f(1) = 1


# 所以可得
# f(1) = 1               # 边界
# f(2) = 2                  # 边界
# f(3) = f(2) + f(1) = 3
# f(n) = f(n-1) + f(n-2)  # 状态转移方程式

# 迭代暴力解法
# def get_count(n):
#     if n == 1 or n == 2:
#         return n
#     return get_count(n - 1) + get_count(n - 2)

# 备忘录优化
# def get_count(n):
#     if n == 1 or n == 2:
#         return n
#     l = [1, 2]
#     for i in range(3, n):
#         l[0], l[1] = l[1], l[0] + l[1]
#         return l[0] + l[1]

# DP 解法
def get_count(n):
    dp = [0] * n
    dp[0] = 1
    dp[1] = 2
    for i in range(2, n):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n-1]

if __name__ == '__main__':
    print(get_count(10))  # 89
    print(get_count(3))  # 3
    print(get_count(5))  # 8

# 这里拿5个台阶来复盘， 前面写好了10个台阶， 我们取一部分
# f(5) = f(4) + f(3)
# f(4) = f(3) + f(2)
# f(3) = f(2) + f(1)
# f(2) = 2  # 两种走法
# f(1) = 1
# 综合可得 f(5) = f(3) + f(2) + f(3)
#              = f(2) + f(1) + f(2) + f(2) + 1
#              = 2 + 1 + 2 + 2 + 1
#              = 8
